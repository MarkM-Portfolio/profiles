/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* OCO Source Materials                                              */
/*                                                                   */
/* Copyright IBM Corp. 2011, 2016                                    */
/*                                                                   */
/* The source code for this program is not published or otherwise    */
/* divested of its trade secrets, irrespective of what has been      */
/* deposited with the U.S. Copyright Office.                         */
/*                                                                   */
/* ***************************************************************** */

package com.ibm.lconn.profiles.internal.bss;

import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.lang.StringUtils;
import com.ibm.connections.directory.services.data.DSObject;
import com.ibm.lconn.commands.IPlatformCommandConstants;
import com.ibm.lconn.commands.IPlatformCommandConsumer;
import com.ibm.lconn.commands.IPlatformCommandRecord;
import com.ibm.lconn.commands.IPlatformCommandResponse;
import com.ibm.lconn.commands.PlatformCommandResponse;
import com.ibm.lconn.profiles.internal.bss.commands.BSSUtil;
import com.ibm.lconn.profiles.internal.bss.commands.BaseBssCommand;
import com.ibm.lconn.profiles.internal.bss.commands.LLISProfileUpdateCommand;
import com.ibm.lconn.profiles.internal.bss.commands.SuccessCommand;
import com.ibm.lconn.profiles.internal.config.MTConfigHelper;
import com.ibm.lconn.profiles.internal.service.AppServiceContextAccess;
import com.ibm.lconn.profiles.internal.service.TDIProfileService;
import com.ibm.lconn.profiles.internal.util.waltz.WaltzClient;
import com.ibm.lconn.profiles.internal.util.waltz.WaltzClientFactory;
import com.ibm.peoplepages.util.appcntx.AdminContext;
import com.ibm.peoplepages.util.appcntx.AppContextAccess;
import com.ibm.peoplepages.util.appcntx.AppContextAccess.Context;

// note: LLIS commands run with the LLISMockAdmin account. There is a subtlety with journaling on the
// cloud. See ocs work item https://swgjazz.ibm.com:8004/jazz/resource/itemName/com.ibm.team.workitem.WorkItem/172833
// briefly, journaling is configured to ignore events generated by MockAdmin user with email
// MockAdmin.DEFAULT_ADMIN_EMAIL = admin@profiles.com. The above work items indicate they want journaling
// for LLIS updates (not sure why these are different from BSS), so we will generate events by a user
// with email LLISMockAdmin.DEFAULT_LLIS_ADMIN_EMAIL = "llisadmin@profiles.com".

public class LLISCommandConsumer implements IPlatformCommandConsumer {

	private static final Logger LOGGER = Logger.getLogger(LLISCommandConsumer.class.getName(),"com.ibm.peoplepages.internal.resources.messages");
	
	private static WaltzClient waltzclient = WaltzClientFactory.INSTANCE().getWaltzClient();
	private TDIProfileService tdiProfileService;
	private boolean isLoggable = LOGGER.isLoggable(Level.FINEST);
	
	public LLISCommandConsumer(){
		tdiProfileService = AppServiceContextAccess.getContextObject(TDIProfileService.class);
	}

	public IPlatformCommandResponse consumeCommand(final IPlatformCommandRecord command) {
		// log entry
		if (isLoggable){ LOGGER.entering("LLISCommandConsumer","consumeCommand",command); }
		IPlatformCommandResponse rtnVal = executeCommand(command);
		// log exit
		if (isLoggable){ LOGGER.exiting("LLISCommandConsumer","consumeCommand"); }
		return rtnVal;
	}

	private IPlatformCommandResponse executeCommand(IPlatformCommandRecord command) {
		// log entry
		if (isLoggable) { LOGGER.entering("LLISCommandConsumer", "executeCommand");	}
		
		// we used to print out all bss commands as it is exceedingly tedious to get relevant trace and logs from ops.
		// we've been asked to curtail the logging to trace and only print the command on error cases.
		// level FINE  check so we can (hopefully) set this w/o getting all the detailed trace info. fvt is used to looking
		// for this printout.
		if (LOGGER.isLoggable(Level.FINE)) {
			LOGGER.info("Received LLIS command: "+ BSSUtil.getPrintString(command));
		}
		
		IPlatformCommandResponse response = null;
		String commandName = command.getCommandName();
		BaseBssCommand bc = null;
		Context origCtx = AppContextAccess.getContext(); // expect this is null
		String customerExId = null;

		try {
			// Update Profile Command
			if (commandName.equals(IPlatformCommandConstants.LLIS_PROFILE_UPDATE_PREPARE_COMMAND)) {
				customerExId = setContextForUserCommand(command);
				bc = new LLISProfileUpdateCommand(command, BaseBssCommand.COMMAND_PHASE.PREPARE);
			}
			else if (commandName.equals(IPlatformCommandConstants.LLIS_PROFILE_UPDATE_COMMAND)) {
				// command must either create or update a tenant.
				customerExId = setContextForUserCommand(command);
				bc = new LLISProfileUpdateCommand(command, BaseBssCommand.COMMAND_PHASE.EXECUTE);
			}
			// quietly ignore guest org
			if (bc != null){
				if (MTConfigHelper.isLotusLiveGuestOrg(customerExId)){
					bc = new SuccessCommand(command,bc.getCommandPhase(),"Connections Profiles ignores guest org requests");
				}
			}
			// Build Response
			if (bc != null) {
				response = bc.execute();
				// if we see a fail code, print the command message. it is up to the worker classes to add enough info.
				// we should never have a null response.
				if (response.getResponseCode() != IPlatformCommandConstants.SUCCESS){
					LOGGER.warning(response.getResponseMessage());
				}
			}
			else {
				response = new PlatformCommandResponse(command, IPlatformCommandConstants.FAIL_UNKNOWN_COMMAND, BaseBssCommand.getMessage(
						command, "err.unknown.command", commandName));
			}
		}
		catch (Throwable t) {
			if (isLoggable) {
				LOGGER.throwing("LLISCommandConsumer", "executeCommand", t);
			}
			StringBuffer tString = BSSUtil.throwableString(t);
			BSSUtil.logError(LOGGER, command, tString.toString());
			// adding stack trace might expose stack info to customer? we do add stack for bss app.
			response = new PlatformCommandResponse(command, IPlatformCommandConstants.FAIL_GENERAL, t.getMessage());
		}
		finally{
			AppContextAccess.setContext(origCtx);
		}
		// log exit
		if (isLoggable){ LOGGER.exiting("LLISCommandConsumer","executeCommand"); }
		return response;
	}

	// the tenant does not exist and we cannot expect to find a tenantKey.
	public String setAdminContextForCustomerCommand(IPlatformCommandRecord command){
		// look for customer id
		String custExId = (String) command.getProperties().get(IPlatformCommandConstants.DIRECTORYID);
		if (custExId == null) custExId = (String) command.getProperties().get(IPlatformCommandConstants.SUBSCRIBER_ID); // LLIS uses different key from BSS to denote the profile GUID

		AdminContext context = AdminContext.getLLISAdminContext(custExId);
		AppContextAccess.setContext(context);
		return custExId;
	}
	
	private String setContextForUserCommand(IPlatformCommandRecord command) throws Exception {
		// bss should provide tenant directory id as well as the user/subscriber id
		// GAD/MT sets the org's id with IPlatformCommandConstants.LOTUSLIVE_CUSTOMER_ID
		// (unless they have forgotten to). not sure what smartcloud uses as the
		// identifier.
		String custExId = (String) command.getProperties().get(IPlatformCommandConstants.LOTUSLIVE_CUSTOMER_ID);
		if(custExId == null) custExId = (String) command.getProperties().get(IPlatformCommandConstants.CUSTOMER_ID); // LLIS uses different key from BSS to denote the org/tenant ID

		// don't bother looking up more info if we have the guest (this tenant does not exist)
		if (MTConfigHelper.isLotusLiveGuestOrg(custExId) == false) {
			// as of 05/15/2013, GAD/MT does not pass in org's id on all user commands.
			// as of 11/5/2013 smartcloud does pass it in
			if (StringUtils.isEmpty(custExId) == true) {
				custExId = retrieveTenantExidForSubscriber(command);
				LOGGER.warning("LLIS did not send organization id in LLIS command:" + command);
				if (isLoggable) {
					LOGGER.finer("setContextForUserCommand resolved tenantExId to: " + custExId);
				}
			}
			String tenantKey = null;
			if (StringUtils.isEmpty(custExId) == false) {
				// retrieve the internal key for this tenant
				tenantKey = findTenantKey(custExId);
				if (isLoggable) {
					LOGGER.finer("setContextForUserCommand resolved tenant key to: " + tenantKey);
				}
			}
			else {
				if (LOGGER.isLoggable(Level.SEVERE)) {
					LOGGER.severe("unable to locate a tenant exid for: " + command);
				}
				throw new Exception("setContextForUserCommand cannot resolve organization id for command: " + command);
			}
			if (StringUtils.isEmpty(tenantKey) == false) {
				AdminContext context = AdminContext.getLLISAdminContext(tenantKey);
				AppContextAccess.setContext(context);
				if (isLoggable) {
					LOGGER.finer("setContextForUserCommand set AppContext tenantKey " + tenantKey);
				}
			}
			else {
				if (isLoggable) {
					LOGGER.finer("unable to locate a tenant key for: " + command);
				}
				throw new Exception("LLISConsumer cannot resolve internal organization id for command: " + command);
			}
		}
		return custExId;
	}

	private String retrieveTenantExidForSubscriber(IPlatformCommandRecord command) throws Exception {
		String rtnVal = null;
		String subscriberId = (String) command.getProperties().get(IPlatformCommandConstants.DIRECTORYID);
		String customerId = (String) command.getProperties().get(IPlatformCommandConstants.CUSTOMER_ID);
		 // LLIS uses different key from BSS to denote the profile GUID
		if (subscriberId == null) subscriberId = (String) command.getProperties().get(IPlatformCommandConstants.SUBSCRIBER_ID);
		DSObject subscriber = waltzclient.exactUserIDMatch(subscriberId,customerId);
		if (subscriber != null) {
			rtnVal = subscriber.get_orgid();
		}
		
		return rtnVal;
	}
	
	private String findTenantKey(String tenantExId){
		String rtnVal = tdiProfileService.getTenantKey(tenantExId);
		return rtnVal;
	}
}
